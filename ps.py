"""
DP 문제인 것 같으면 목표/재료 구분할 것
    - 목표: 무엇을 구하는가 -> 갯수
    - 재료: 최종적으로 구하려는 갯수를 하나하나 세는게 아니고, 전에 셌던 갯수를 재사용한다
        - ex1) 계단 오르기 문제: 갑자기 5번째 이후 계단을 고려하면 안된다. 237번째 계단을 줘도 규칙이 1,2계단 단위임을 고려.
        - ex2) Four Squares 문제: 갑자기 6번째 이전, 13번째 이전을 구하지 않는다. N = 11339를 줘도 i-1, i-4, i-9를 사용할 것.
"""
N = int(input())
dp = [0,1]

for i in range(2,N+1): ## ~N까지, 해당 수에 도달하기 전의 위치에는 i-1, i-4, i-9 등이 있다.
    tmp_min = 50001 # 입력의 최대값인 50000이 들어와도 1+1+...+1 = 1*50000이므로 50001로 선언
    j = 1

    while j**2 <= i: ## 주어진 재료는 제곱수이므로, 제곱수에 대해서만 탐색
        tmp_min = min(tmp_min, dp[i-(j**2)]) ## 만약 j**2 == i 면 dp[0] = 0으로 빠지지만, dp에 append 할 때는 +1 한 상태로 들어간다
        j += 1
    dp.append(tmp_min+1)

print(dp[N])
    